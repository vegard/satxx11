<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN" "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd">
<book>
	<title>SAT++11 Manual</title>
	<bookinfo>
		<author>
			<firstname>Vegard</firstname>
			<surname>Nossum</surname>
		</author>
		<affiliation>
			<address><email>vegardno@ifi.uio.no</email></address>
		</affiliation>
	</bookinfo>

<!--
	<preface>
		<title>Preface</title>

		<abstract>
			<simpara>ssdfsdf</simpara>
		</abstract>
	</preface>
-->

	<part>
		<title>Introduction</title>

		<chapter>
			<title>Overview</title>
			<para>This is the manual for the software program/project <application>SAT++11</application> (sometimes written <application>satxx11</application>). <application>SAT++11</application> aims to be a fast, scalable, and extensible parallel SAT solver. Efficient compile-time extensibility is one of the most important features of the code base, and we achieve it through creative use of C++ template metaprogramming. In fact, we rely on many of the features of the new C++ language standard, C++11, a fact which is reflected in the name of the solver.</para>
			<para>The first part of this manual (<xref linkend="usage" />) describes how to build the solver program and how to run it. The second part (<xref linkend="plugin-architecture" />) is a reference to the plugin architecture that allows one to write compile-time extensions for the solver, including a tutorial that explains the process of writing a plugin step by step. The last part (<xref linkend="builtins" />) is a reference to the built-in plugins that are bundled with the solver core.</para>
			<para>Although the solver was written from scratch, many algorithms, heuristics, and techniques were heavily inspired by (and sometimes copied from) their respective counterparts in other, already existing SAT solvers like Chaff, MiniSat, CryptoMiniSat, lingeling, and SAT4J. The main contribution of <application>SAT++11</application> is to bring the extensibility of SAT4J together with the raw efficiency of C++ solvers like MiniSat.</para>
		</chapter>
	</part>

	<part id="usage">
		<title>Usage</title>

		<chapter>
			<title>Building the solver</title>
			<para>Before <application>SAT++11</application> can be compiled, the following prerequisites must be installed:</para>
			<itemizedlist>
				<listitem><para>Boost.Program_options (<filename>libboost-program-options-dev</filename>)</para></listitem>
				<listitem><para>Git (<filename>git</filename>)</para></listitem>
				<listitem><para>GNU C++ Compiler (<filename>gcc</filename>)</para></listitem>
			</itemizedlist>
			<para>To compile the solver, simply run the following command in the top-level project directory:</para>
			<para><userinput>bash make.sh</userinput></para>
		</chapter>

		<chapter>
			<title>Building the documentation</title>
			<para>In order to build the documentation, the following prerequisites must be installed:</para>
			<itemizedlist>
				<listitem><para>Docbook (<filename>docbook</filename>, <filename>docbook-xsl</filename>)</para></listitem>
				<listitem><para>Doxygen (<filename>doxygen</filename>)</para></listitem>
				<listitem><para>Libxslt1.1 (<filename>libxslt1.1</filename>)</para></listitem>
				<listitem><para>xmlto (<filename>xmlto</filename>)</para></listitem>
			</itemizedlist>
			<para>To compile the API reference, run the following command in the top-level project directory:</para>
			<para><userinput>doxygen</userinput></para>
			<para>The generated files can be found in <filename>doc/html/</filename>.</para>
			<para>To compile the manual, run the following commands in the top-level project directory:</para>
			<para><userinput>cd doc &amp;&amp; bash make.sh</userinput></para>
			<para>The generated files can be found in <filename>doc/manual/</filename>.</para>
		</chapter>

		<chapter>
			<title>Running the solver</title>

			<section>
				<title>Command-line options</title>
				<warning><para>This list of options may not be complete or up to date. Please also check the output of <userinput>./solver --help</userinput> for additional options.</para></warning>
				<variablelist>
					<varlistentry><term><userinput>--keep-going</userinput></term><listitem><para>Find all solutions</para></listitem></varlistentry>
					<varlistentry><term><userinput>--threads arg</userinput></term><listitem><para>Number of threads (default: number of available cores)</para></listitem></varlistentry>
					<varlistentry><term><userinput>--seed arg</userinput></term><listitem><para>Random number generator seed (default: current time)</para></listitem></varlistentry>
				</variablelist>
			</section>

			<section>
				<title>Example</title>
				<para>To find all solutions to the input file <filename>~/sha1.cnf</filename> using 4 threads, run the command:</para>
				<para><userinput>./solver --keep-going --threads 4 ~/sha1.cnf</userinput></para>
			</section>
		</chapter>

		<chapter>
			<title>Input file format</title>
			<para>As the main rule, input files to the solver are given in the traditional DIMACS CNF format. In general, this is a line-oriented plaintext format, meaning that each line of input is parsed as a unit. At the beginning of the file, we may have any number of comment lines; these lines start with a <literal>c</literal>. Following the comments (if any), there comes exactly one problem line; this line starts with a <literal>p</literal> and two numeric parameters. The first parameter is the number of variables in the instance, and the second parameter is the number of clauses. After the problem line follows the clauses of the instance. Each clause is a space-separated list of literals ending in <literal>0</literal>. Negative literals consist of <literal>-</literal> followed by the variable number, while positive literals consist only of the variable number.</para>
			<para>Additionally, in the traditional DIMACS CNF format, variables are numbered from 1 to the number of variables, inclusive. However, we are not so strict with variable numbering. In fact, we are not strict at all. Comment lines may appear anywhere in the file, the problem line is entirely optional, and variables need not be numbered sequentially.</para>
			<example>
				<title>Example CNF file</title>
				<programlisting>c An example CNF file
p cnf 3 4
1 -2 0
-1 2 0
-2 3 0
1 2 3 0</programlisting>
			</example>
			<para>In the future, we might support additional types of constraints, e.g. parity constraints, cardinality constraints, or linear zero-one constraints.</para>
		</chapter>
	</part>

	<part id="plugin-architecture">
		<title>Plugin architecture</title>

		<chapter>
			<title>Overview</title>
			<para>The plugin architecture of <application>SAT++11</application> is what allows us to modify and extend the solver and its heuristics. In fact, more than that, even the very core of the solver, the propagation engine, is a plugin that can be replaced by another.</para>
			<para>Now, you may ask what the point of having a plugin architecture really is. Can't we just edit <filename>Solver.cpp</filename> like we used to do with <application>MiniSat</application>? Well, as it turns out, that is a perfect recipe for making a mess. And, although the plugin architecture seems rigid, it actually allows us to do a lot more with less work on the part of the programmer. Consider for example that you would like to test your hypothesis about a brand new decision variable heuristic. In the old way of doing things, you would have to have a look around and look at all the parts that might be affected by the old heuristic; in fact, if you wanted to keep the other heuristic around so that you could switch between the two, you would end up having to keep track of the functions and data structures for both.</para>
			<para>With the plugin architecture, creating a new decision variable heuristic is as simple as writing a new (template) class. The functions and data structures for the new plugin are entirely self-contained and there is no need to change any of the existing files. Moreover, if you don't want to use the old heuristic, you don't need to spend any time whatsoever on removing it. You simply have to pass your new heuristic to the solver instead of the old one.</para>
			<para>Separation of duties is a very powerful concept, because it allows us to completely ignore other, irrelevant parts of a program. Not only that, but SAT solvers are increasingly complex beasts, and we absolutely need to keep track of less things at a time in order to stay in charge of our own programs. If we don't, we can have no hope of making any progress, except perhaps by chance.</para>
			<para>Additionally, the plugin architecture of <application>SAT++11</application> is based on C++ templates, which means that there is absolutely zero runtime overhead compared with implementing everything in a single file or class. Since plugin selection happens at compile-time, there is no overhead from calling virtual functions (as, indeed, there are no virtual functions to begin with).</para>
			<para>Now, there are two types of plugins: designated plugins (<xref linkend="designated-plugins" />), and generic plugins (<xref linkend="generic-plugins" />). In short, designated plugins are plugins with a certain predefined (“designated”) purpose, like plugins that implement the decision literal heuristic or the restart policy. Generic plugins, however, don't fulfill a particular required purpose, but extend the core functionality of the solver in various ways. Generic plugins typically listen to certain events and can interact with the environment (such as e.g. the plugin responsible for printing statistics to the console), or they implement algorithms that run in-between the regular DPLL-style searches (such as e.g. simplification passes).</para>
		</chapter>

		<chapter id="designated-plugins">
			<title>Designated plugins</title>
			<para>Designated plugins are plugins with a certain predefined purpose. For the moment, the <literal>class solver</literal> takes the following types of designated plugins as its arguments:</para>
			<variablelist>
				<varlistentry><term>Random</term><listitem><para>Random number generator. Any of the standard C++11 random number generators (e.g. <literal>std::minstd_rand</literal>, <literal>std::ranlux24_base</literal>, or <literal>std::mt19937</literal>) will do.</para></listitem></varlistentry>
				<varlistentry><term>Decide</term><listitem><para>Decision literal heuristic.</para></listitem></varlistentry>
				<varlistentry><term>Propagate</term><listitem><para>Propagation engine.</para></listitem></varlistentry>
				<varlistentry><term>Analyze</term><listitem><para>Conflict analysis engine.</para></listitem></varlistentry>
				<varlistentry><term>Send</term><listitem><para>Outgoing-clause sharing heuristic.</para></listitem></varlistentry>
				<varlistentry><term>Receive</term><listitem><para>Incoming-clause acceptance heuristic.</para></listitem></varlistentry>
				<varlistentry><term>NextRestart</term><listitem><para>Restart policy.</para></listitem></varlistentry>
				<varlistentry><term>Reduce</term><listitem><para>Clause database reduction heuristic.</para></listitem></varlistentry>
				<varlistentry><term>Simplify</term><listitem><para>Simplification passes. More than one type of simplification pass can be used at a time using <literal>simplify_list&lt;&gt;</literal>.</para></listitem></varlistentry>
				<varlistentry><term>Plugin</term><listitem><para>Generic plugins. More than one generic plugin can be used at a time using <literal>plugin_list&lt;&gt;</literal>.</para></listitem></varlistentry>
			</variablelist>
			<example>
				<title>Example <literal>solver</literal> configuration</title>
				<programlisting>using namespace satxx11;

typedef solver&lt;ranlux24_base,
    decide_cached_polarity&lt;decide_vsids&lt;95&gt;&gt;,
    propagate_watchlists&lt;&gt;,
    analyze_1uip&lt;minimise_minisat&gt;,
    send_size&lt;4&gt;
    receive_all,
    restart_multiply&lt;restart_luby, restart_fixed&lt;400&gt;&gt;,
    reduce_size&lt;2&gt;
    simplify_failed_literal_probing,
    plugin_list&lt;plugin_stdio&gt;&gt; my_solver&gt;</programlisting>
			</example>
		</chapter>

		<chapter id="generic-plugins">
			<title>Generic plugins</title>
			<para>TODO</para>
		</chapter>

		<chapter>
			<title>Tutorial: Writing a plugin</title>
			<para>TODO</para>
		</chapter>
	</part>

	<part id="builtins">
		<title>Built-in plugins</title>

		<chapter>
			<title>Branching literal heuristics</title>

			<section>
				<title><literal>decide_cached_polarity</literal></title>
				<para>TODO</para>
			</section>
		</chapter>

		<chapter>
			<title>Branching variable heuristics</title>

			<section>
				<title><literal>decide_vsids</literal></title>
				<para>TODO</para>
			</section>

			<section>
				<title><literal>decide_random</literal></title>
				<para>TODO</para>
			</section>
		</chapter>

		<chapter>
			<title>Propagation engines</title>

			<section>
				<title><literal>propagate_watchlists</literal></title>
				<para>TODO</para>
			</section>
		</chapter>

		<chapter>
			<title>Conflict analysis engines</title>

			<section>
				<title><literal>analyze_1uip</literal></title>
				<para>TODO</para>
			</section>
		</chapter>

		<chapter>
			<title>Conflict clause minimisation engines</title>

			<section>
				<title><literal>minimise_minisat</literal></title>
				<para>TODO</para>
			</section>
			<section>
				<title><literal>minimise_noop</literal></title>
				<para>TODO</para>
			</section>
		</chapter>

		<chapter>
			<title>Clause sharing heuristics</title>

			<section>
				<title><literal>send_size</literal></title>
				<para>TODO</para>
			</section>

			<section>
				<title><literal>receive_all</literal></title>
				<para>TODO</para>
			</section>
		</chapter>

		<chapter>
			<title>Restart heuristics</title>

			<section>
				<title><literal>restart_luby</literal></title>
				<para>TODO</para>
			</section>
			<section>
				<title><literal>restart_geometric</literal></title>
				<para>TODO</para>
			</section>
			<section>
				<title><literal>restart_random</literal></title>
				<para>TODO</para>
			</section>
			<section>
				<title><literal>restart_fixed</literal></title>
				<para>TODO</para>
			</section>
			<section>
				<title><literal>restart_multiply</literal></title>
				<para>TODO</para>
			</section>
		</chapter>

		<chapter>
			<title>Clause removal heuristics</title>

			<section>
				<title><literal>reduce_noop</literal></title>
				<para>TODO</para>
			</section>
			<section>
				<title><literal>reduce_size</literal></title>
				<para>TODO</para>
			</section>
		</chapter>

		<chapter>
			<title>Simplification schemes</title>

			<section>
				<title><literal>simplify_failed_literal_probing</literal></title>
				<para>TODO</para>
			</section>
			<section>
				<title><literal>simplify_list</literal></title>
				<para>TODO</para>
			</section>
		</chapter>

		<chapter>
			<title>Generic plugins</title>

			<section>
				<title><literal>plugin_base</literal></title>

				<section>
					<title>Synopsis</title>
					<para><code>plugin_base</code></para>
				</section>

				<section>
					<title>Description</title>
					<para>The <literal>plugin_base</literal> plugin is not meant to do anything by itself; instead, it provides empty implementations of all the event handlers for generic plugins so that other plugins do not need to provide their own empty implementations of unused event handlers.</para>
				</section>
			</section>
			<section>
				<title><literal>plugin_list</literal></title>

				<section>
					<title>Synopsis</title>
					<para><code>plugin_list&lt;plugin1, plugin2, ...&gt;</code></para>
				</section>

				<section>
					<title>Description</title>
					<para>The <literal>plugin_list</literal> plugin dispatches all events to the plugins <code>plugin1</code>, <code>plugin2</code>, etc. If the list of plugins is empty, this plugin is effectively a no-op.</para>
				</section>
			</section>
			<section>
				<title><literal>plugin_stdio</literal></title>
				<para>TODO</para>
			</section>
			<section>
				<title><literal>plugin_graphviz</literal></title>

				<section>
					<title>Synopsis</title>
					<para><code>plugin_graphviz&lt;bool show_implications = false&gt;</code></para>
				</section>

				<section>
					<title>Description</title>
					<para>The <literal>plugin_graphviz</literal> plugin constructs a <application>GraphViz</application> graph, written to the files <filename>graph-0.dot</filename>, <filename>graph-1.dot</filename>, etc. (where 0, 1, etc. are the thread indices).</para>
					<para>To plot the <filename>.dot</filename> files, use the <command>dot</command> command like this:</para>
					<para><userinput>dot -Tpdf &lt; graph-0.dot &gt; graph-0.pdf</userinput></para>
				</section>

				<section>
					<title>Example</title>
					<figure>
						<title>Example GraphViz output</title>
						<graphic fileref="graph.png" />
					</figure>
				</section>
			</section>
		</chapter>
	</part>
</book>
