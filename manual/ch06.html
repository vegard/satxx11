<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 6. Overview</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="SAT++11 Manual"><link rel="up" href="pt03.html" title="Part III. Plugin architecture"><link rel="prev" href="pt03.html" title="Part III. Plugin architecture"><link rel="next" href="ch07.html" title="Chapter 7. Designated plugins"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 6. Overview</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="pt03.html">Prev</a> </td><th width="60%" align="center">Part III. Plugin architecture</th><td width="20%" align="right"> <a accesskey="n" href="ch07.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter 6. Overview"><div class="titlepage"><div><div><h2 class="title"><a name="idp32214656"></a>Chapter 6. Overview</h2></div></div></div><p>The plugin architecture of <span class="application">SAT++11</span> is what allows us to modify and extend the solver and its heuristics. In fact, more than that, even the very core of the solver, the propagation engine, is a plugin that can be replaced by another.</p><p>Now, you may ask what the point of having a plugin architecture really is. Can't we just edit <code class="filename">Solver.cpp</code> like we used to do with <span class="application">MiniSat</span>? Well, as it turns out, that is a perfect recipe for making a mess. And, although the plugin architecture seems rigid, it actually allows us to do a lot more with less work on the part of the programmer. Consider for example that you would like to test your hypothesis about a brand new decision variable heuristic. In the old way of doing things, you would have to have a look around and look at all the parts that might be affected by the old heuristic; in fact, if you wanted to keep the other heuristic around so that you could switch between the two, you would end up having to keep track of the functions and data structures for both.</p><p>With the plugin architecture, creating a new decision variable heuristic is as simple as writing a new (template) class. The functions and data structures for the new plugin are entirely self-contained and there is no need to change any of the existing files. Moreover, if you don't want to use the old heuristic, you don't need to spend any time whatsoever on removing it. You simply have to pass your new heuristic to the solver instead of the old one.</p><p>Separation of duties is a very powerful concept, because it allows us to completely ignore other, irrelevant parts of a program. Not only that, but SAT solvers are increasingly complex beasts, and we absolutely need to keep track of less things at a time in order to stay in charge of our own programs. If we don't, we can have no hope of making any progress, except perhaps by chance.</p><p>Additionally, the plugin architecture of <span class="application">SAT++11</span> is based on C++ templates, which means that there is absolutely zero runtime overhead compared with implementing everything in a single file or class. Since plugin selection happens at compile-time, there is no overhead from calling virtual functions (as, indeed, there are no virtual functions to begin with).</p><p>Now, there are two types of plugins: designated plugins (<a class="xref" href="ch07.html" title="Chapter 7. Designated plugins">Chapter 7, <i>Designated plugins</i></a>), and generic plugins (<a class="xref" href="ch08.html" title="Chapter 8. Generic plugins">Chapter 8, <i>Generic plugins</i></a>). In short, designated plugins are plugins with a certain predefined (“designated”) purpose, like plugins that implement the decision literal heuristic or the restart policy. Generic plugins, however, don't fulfill a particular required purpose, but extend the core functionality of the solver in various ways. Generic plugins typically listen to certain events and can interact with the environment (such as e.g. the plugin responsible for printing statistics to the console), or they implement algorithms that run in-between the regular DPLL-style searches (such as e.g. simplification passes).</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pt03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="pt03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part III. Plugin architecture </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 7. Designated plugins</td></tr></table></div></body></html>
