<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Implementing the event handlers</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="SAT++11 Manual"><link rel="up" href="ch09.html" title="Chapter 9. Tutorial: Writing a plugin"><link rel="prev" href="ch09s02.html" title="Creating the class"><link rel="next" href="ch09s04.html" title="Implementing the decision heuristic proper"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Implementing the event handlers</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch09s02.html">Prev</a> </td><th width="60%" align="center">Chapter 9. Tutorial: Writing a plugin</th><td width="20%" align="right"> <a accesskey="n" href="ch09s04.html">Next</a></td></tr></table><hr></div><div class="section" title="Implementing the event handlers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp32265664"></a>Implementing the event handlers</h2></div></div></div><p>The event handlers are functions of the plugin we are writing, and the exact set of events that we need to handle depends on the type of plugin we are writing. For decision variable heuristics, we have to implement handlers for:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Variable assignment and unassignment events; in order to possibly keep track of what variables are eligible for being picked as decision variables.</p></li><li class="listitem"><p>Clause resolution events; in order to possibly bump variable activities (for VSIDS-like heuristics).</p></li><li class="listitem"><p>Clause attachment and detachment events; in order to possibly keep track of what variables/literals occur the most frequently.</p></li><li class="listitem"><p>Conflict events; in order to possibly decay the variable activities (for VSIDS-like heuristics).</p></li></ul></div><p>It doesn't matter that we don't need to know about certain events; empty functions will be completely optimised away by the compiler, since the compiler knows (at compile-time) exactly what functions will be called. This is one of the huge advantages of using a compile-time plugin architecture; there is absolutely no runtime overhead for calling empty event handlers.</p><p>Our event handlers are going to forward the events to the two plugins we are using, just like we did for the constructor:</p><pre class="programlisting">template&lt;class Solver&gt;
void assign(Solver &amp;s, unsigned int variable, bool value)
{
    random.assign(s, variable, value);
    vsids.assign(s, variable, value);
}

template&lt;class Solver&gt;
void unassign(Solver &amp;s, unsigned int variable)
{
    random.unassign(s, variable);
    vsids.unassign(s, variable);
}

template&lt;class Solver&gt;
void resolve(Solver &amp;s, literal lit)
{
    random.resolve(s, lit);
    vsids.resolve(s, lit);
}

template&lt;class Solver&gt;
void resolve(Solver &amp;s, const std::vector&lt;literal&gt; &amp;v)
{
    random.resolve(s, v);
    vsids.resolve(s, v);
}

void attach(clause c)
{
    random.attach(c);
    vsids.attach(c);
}

void detach(clause c)
{
    random.detach(c);
    vsids.detach(c);
}

template&lt;class Solver&gt;
void conflict(Solver &amp;s)
{
    random.conflict(s);
    vsids.conflict(s);
}</pre></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch09s02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch09.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch09s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Creating the class </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Implementing the decision heuristic proper</td></tr></table></div></body></html>
