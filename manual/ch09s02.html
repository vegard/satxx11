<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Creating the class</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="SAT++11 Manual"><link rel="up" href="ch09.html" title="Chapter 9. Tutorial: Writing a plugin"><link rel="prev" href="ch09.html" title="Chapter 9. Tutorial: Writing a plugin"><link rel="next" href="ch09s03.html" title="Implementing the event handlers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Creating the class</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch09.html">Prev</a> </td><th width="60%" align="center">Chapter 9. Tutorial: Writing a plugin</th><td width="20%" align="right"> <a accesskey="n" href="ch09s03.html">Next</a></td></tr></table><hr></div><div class="section" title="Creating the class"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp32257984"></a>Creating the class</h2></div></div></div><p>First of all, we will create a new file that contains all the code for our new heuristic. Let's call it <code class="filename">my_decide.hh</code> and place it in the top-level directory, i.e. alongside <code class="filename">main.cc</code>. This file needs to include the two built-in heuristics that we are reusing, and also declare and define our own class:</p><pre class="programlisting">#ifndef MY_DECIDE_HH
#define MY_DECIDE_HH

#include &lt;satxx11/decide_random.hh&gt;
#include &lt;satxx11/decide_vsids.hh&gt;

using namespace satxx11;

class my_decide {
public:
};

#endif</pre><p>This class will be instantiated once per thread just like all the other plugins. In order to actually use the two built-in heuristics, we have to instantiate them too. This we do by making them members of our new class.</p><pre class="programlisting">class my_decide {
public:
    decide_random random;
    decide_vsids&lt;95&gt; vsids;
};</pre><p>However, decision variable heuristics (as most plugins) will need to know certain information about the solver and the instance as part of their initialisation. For example, the VSIDS heuristic allocates an array of doubles to hold the current activity value for each variable, so it needs to know how many variables there are in the instance. In order for the solver to provide all this information to plugins, it passes a reference to itself as the first argument to most of the plugin's functions and, in this case most importantly, to the constructor. Our constructor, therefore, simply needs to pass this argument on to the two plugins we are using:</p><pre class="programlisting">template&lt;class Solver&gt;
my_decide(Solver &amp;s):
    random(s),
    vsids(s)
{
}</pre><p>At first it may seem a little odd to make the solver type a template parameter, but you will soon get used to it. The reason we have to do this is that the solver class is itself a template class whose type depends on all the plugins it is using! In other words, the solver type depends on what plugins it is using, and we would like our plugin to be independent of the (other) plugins that the solver is using.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch09.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch09.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch09s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 9. Tutorial: Writing a plugin </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Implementing the event handlers</td></tr></table></div></body></html>
